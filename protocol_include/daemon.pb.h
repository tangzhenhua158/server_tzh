// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: daemon.proto

#ifndef PROTOBUF_daemon_2eproto__INCLUDED
#define PROTOBUF_daemon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace daemon_name {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_daemon_2eproto();
void protobuf_AssignDesc_daemon_2eproto();
void protobuf_ShutdownFile_daemon_2eproto();

class serverInfo;
class registerReq;
class registerRsp;
class loginOutReq;
class loginOutRsp;
class heartReq;
class heartRsp;
class queryServerReq;
class queryServerRsp;
class queryDaemonMasterReq;
class queryDaemonMasterRsp;
class syncToServerReq;
class syncToServerRsp;
class electionMasterReq;
class electionMasterRsp;

enum daemon_msg_ret {
  ok = 1,
  fail = 2,
  notexist = 3,
  exist = 4
};
bool daemon_msg_ret_IsValid(int value);
const daemon_msg_ret daemon_msg_ret_MIN = ok;
const daemon_msg_ret daemon_msg_ret_MAX = exist;
const int daemon_msg_ret_ARRAYSIZE = daemon_msg_ret_MAX + 1;

const ::google::protobuf::EnumDescriptor* daemon_msg_ret_descriptor();
inline const ::std::string& daemon_msg_ret_Name(daemon_msg_ret value) {
  return ::google::protobuf::internal::NameOfEnum(
    daemon_msg_ret_descriptor(), value);
}
inline bool daemon_msg_ret_Parse(
    const ::std::string& name, daemon_msg_ret* value) {
  return ::google::protobuf::internal::ParseNamedEnum<daemon_msg_ret>(
    daemon_msg_ret_descriptor(), name, value);
}
// ===================================================================

class serverInfo : public ::google::protobuf::Message {
 public:
  serverInfo();
  virtual ~serverInfo();

  serverInfo(const serverInfo& from);

  inline serverInfo& operator=(const serverInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const serverInfo& default_instance();

  void Swap(serverInfo* other);

  // implements Message ----------------------------------------------

  serverInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const serverInfo& from);
  void MergeFrom(const serverInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::int32 ip() const;
  inline void set_ip(::google::protobuf::int32 value);

  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // required string servername = 3;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 3;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // required int64 serverid = 4;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 4;
  inline ::google::protobuf::int64 serverid() const;
  inline void set_serverid(::google::protobuf::int64 value);

  // optional string extend = 5;
  inline bool has_extend() const;
  inline void clear_extend();
  static const int kExtendFieldNumber = 5;
  inline const ::std::string& extend() const;
  inline void set_extend(const ::std::string& value);
  inline void set_extend(const char* value);
  inline void set_extend(const char* value, size_t size);
  inline ::std::string* mutable_extend();
  inline ::std::string* release_extend();
  inline void set_allocated_extend(::std::string* extend);

  // @@protoc_insertion_point(class_scope:daemon_name.serverInfo)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_extend();
  inline void clear_has_extend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ip_;
  ::google::protobuf::int32 port_;
  ::std::string* servername_;
  ::google::protobuf::int64 serverid_;
  ::std::string* extend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static serverInfo* default_instance_;
};
// -------------------------------------------------------------------

class registerReq : public ::google::protobuf::Message {
 public:
  registerReq();
  virtual ~registerReq();

  registerReq(const registerReq& from);

  inline registerReq& operator=(const registerReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const registerReq& default_instance();

  void Swap(registerReq* other);

  // implements Message ----------------------------------------------

  registerReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const registerReq& from);
  void MergeFrom(const registerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::int32 ip() const;
  inline void set_ip(::google::protobuf::int32 value);

  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // required string servername = 3;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 3;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // optional string extend = 4;
  inline bool has_extend() const;
  inline void clear_extend();
  static const int kExtendFieldNumber = 4;
  inline const ::std::string& extend() const;
  inline void set_extend(const ::std::string& value);
  inline void set_extend(const char* value);
  inline void set_extend(const char* value, size_t size);
  inline ::std::string* mutable_extend();
  inline ::std::string* release_extend();
  inline void set_allocated_extend(::std::string* extend);

  // @@protoc_insertion_point(class_scope:daemon_name.registerReq)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_extend();
  inline void clear_has_extend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ip_;
  ::google::protobuf::int32 port_;
  ::std::string* servername_;
  ::std::string* extend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static registerReq* default_instance_;
};
// -------------------------------------------------------------------

class registerRsp : public ::google::protobuf::Message {
 public:
  registerRsp();
  virtual ~registerRsp();

  registerRsp(const registerRsp& from);

  inline registerRsp& operator=(const registerRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const registerRsp& default_instance();

  void Swap(registerRsp* other);

  // implements Message ----------------------------------------------

  registerRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const registerRsp& from);
  void MergeFrom(const registerRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .daemon_name.daemon_msg_ret ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::daemon_name::daemon_msg_ret ret() const;
  inline void set_ret(::daemon_name::daemon_msg_ret value);

  // required int64 serverid = 2;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 2;
  inline ::google::protobuf::int64 serverid() const;
  inline void set_serverid(::google::protobuf::int64 value);

  // required string servername = 3;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 3;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // @@protoc_insertion_point(class_scope:daemon_name.registerRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_servername();
  inline void clear_has_servername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 serverid_;
  ::std::string* servername_;
  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static registerRsp* default_instance_;
};
// -------------------------------------------------------------------

class loginOutReq : public ::google::protobuf::Message {
 public:
  loginOutReq();
  virtual ~loginOutReq();

  loginOutReq(const loginOutReq& from);

  inline loginOutReq& operator=(const loginOutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const loginOutReq& default_instance();

  void Swap(loginOutReq* other);

  // implements Message ----------------------------------------------

  loginOutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const loginOutReq& from);
  void MergeFrom(const loginOutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 serverid = 1;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 1;
  inline ::google::protobuf::int64 serverid() const;
  inline void set_serverid(::google::protobuf::int64 value);

  // required string servername = 2;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 2;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // @@protoc_insertion_point(class_scope:daemon_name.loginOutReq)
 private:
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_servername();
  inline void clear_has_servername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 serverid_;
  ::std::string* servername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static loginOutReq* default_instance_;
};
// -------------------------------------------------------------------

class loginOutRsp : public ::google::protobuf::Message {
 public:
  loginOutRsp();
  virtual ~loginOutRsp();

  loginOutRsp(const loginOutRsp& from);

  inline loginOutRsp& operator=(const loginOutRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const loginOutRsp& default_instance();

  void Swap(loginOutRsp* other);

  // implements Message ----------------------------------------------

  loginOutRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const loginOutRsp& from);
  void MergeFrom(const loginOutRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .daemon_name.daemon_msg_ret ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::daemon_name::daemon_msg_ret ret() const;
  inline void set_ret(::daemon_name::daemon_msg_ret value);

  // @@protoc_insertion_point(class_scope:daemon_name.loginOutRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static loginOutRsp* default_instance_;
};
// -------------------------------------------------------------------

class heartReq : public ::google::protobuf::Message {
 public:
  heartReq();
  virtual ~heartReq();

  heartReq(const heartReq& from);

  inline heartReq& operator=(const heartReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const heartReq& default_instance();

  void Swap(heartReq* other);

  // implements Message ----------------------------------------------

  heartReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const heartReq& from);
  void MergeFrom(const heartReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 serverid = 1;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 1;
  inline ::google::protobuf::int64 serverid() const;
  inline void set_serverid(::google::protobuf::int64 value);

  // required string servername = 2;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 2;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // @@protoc_insertion_point(class_scope:daemon_name.heartReq)
 private:
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_servername();
  inline void clear_has_servername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 serverid_;
  ::std::string* servername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static heartReq* default_instance_;
};
// -------------------------------------------------------------------

class heartRsp : public ::google::protobuf::Message {
 public:
  heartRsp();
  virtual ~heartRsp();

  heartRsp(const heartRsp& from);

  inline heartRsp& operator=(const heartRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const heartRsp& default_instance();

  void Swap(heartRsp* other);

  // implements Message ----------------------------------------------

  heartRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const heartRsp& from);
  void MergeFrom(const heartRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .daemon_name.daemon_msg_ret ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::daemon_name::daemon_msg_ret ret() const;
  inline void set_ret(::daemon_name::daemon_msg_ret value);

  // @@protoc_insertion_point(class_scope:daemon_name.heartRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static heartRsp* default_instance_;
};
// -------------------------------------------------------------------

class queryServerReq : public ::google::protobuf::Message {
 public:
  queryServerReq();
  virtual ~queryServerReq();

  queryServerReq(const queryServerReq& from);

  inline queryServerReq& operator=(const queryServerReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const queryServerReq& default_instance();

  void Swap(queryServerReq* other);

  // implements Message ----------------------------------------------

  queryServerReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const queryServerReq& from);
  void MergeFrom(const queryServerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string servername = 1;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 1;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // @@protoc_insertion_point(class_scope:daemon_name.queryServerReq)
 private:
  inline void set_has_servername();
  inline void clear_has_servername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* servername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static queryServerReq* default_instance_;
};
// -------------------------------------------------------------------

class queryServerRsp : public ::google::protobuf::Message {
 public:
  queryServerRsp();
  virtual ~queryServerRsp();

  queryServerRsp(const queryServerRsp& from);

  inline queryServerRsp& operator=(const queryServerRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const queryServerRsp& default_instance();

  void Swap(queryServerRsp* other);

  // implements Message ----------------------------------------------

  queryServerRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const queryServerRsp& from);
  void MergeFrom(const queryServerRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .daemon_name.serverInfo serInfos = 1;
  inline int serinfos_size() const;
  inline void clear_serinfos();
  static const int kSerInfosFieldNumber = 1;
  inline const ::daemon_name::serverInfo& serinfos(int index) const;
  inline ::daemon_name::serverInfo* mutable_serinfos(int index);
  inline ::daemon_name::serverInfo* add_serinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::daemon_name::serverInfo >&
      serinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::daemon_name::serverInfo >*
      mutable_serinfos();

  // @@protoc_insertion_point(class_scope:daemon_name.queryServerRsp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::daemon_name::serverInfo > serinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static queryServerRsp* default_instance_;
};
// -------------------------------------------------------------------

class queryDaemonMasterReq : public ::google::protobuf::Message {
 public:
  queryDaemonMasterReq();
  virtual ~queryDaemonMasterReq();

  queryDaemonMasterReq(const queryDaemonMasterReq& from);

  inline queryDaemonMasterReq& operator=(const queryDaemonMasterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const queryDaemonMasterReq& default_instance();

  void Swap(queryDaemonMasterReq* other);

  // implements Message ----------------------------------------------

  queryDaemonMasterReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const queryDaemonMasterReq& from);
  void MergeFrom(const queryDaemonMasterReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:daemon_name.queryDaemonMasterReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static queryDaemonMasterReq* default_instance_;
};
// -------------------------------------------------------------------

class queryDaemonMasterRsp : public ::google::protobuf::Message {
 public:
  queryDaemonMasterRsp();
  virtual ~queryDaemonMasterRsp();

  queryDaemonMasterRsp(const queryDaemonMasterRsp& from);

  inline queryDaemonMasterRsp& operator=(const queryDaemonMasterRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const queryDaemonMasterRsp& default_instance();

  void Swap(queryDaemonMasterRsp* other);

  // implements Message ----------------------------------------------

  queryDaemonMasterRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const queryDaemonMasterRsp& from);
  void MergeFrom(const queryDaemonMasterRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .daemon_name.serverInfo serInfo = 1;
  inline bool has_serinfo() const;
  inline void clear_serinfo();
  static const int kSerInfoFieldNumber = 1;
  inline const ::daemon_name::serverInfo& serinfo() const;
  inline ::daemon_name::serverInfo* mutable_serinfo();
  inline ::daemon_name::serverInfo* release_serinfo();
  inline void set_allocated_serinfo(::daemon_name::serverInfo* serinfo);

  // @@protoc_insertion_point(class_scope:daemon_name.queryDaemonMasterRsp)
 private:
  inline void set_has_serinfo();
  inline void clear_has_serinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::daemon_name::serverInfo* serinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static queryDaemonMasterRsp* default_instance_;
};
// -------------------------------------------------------------------

class syncToServerReq : public ::google::protobuf::Message {
 public:
  syncToServerReq();
  virtual ~syncToServerReq();

  syncToServerReq(const syncToServerReq& from);

  inline syncToServerReq& operator=(const syncToServerReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const syncToServerReq& default_instance();

  void Swap(syncToServerReq* other);

  // implements Message ----------------------------------------------

  syncToServerReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const syncToServerReq& from);
  void MergeFrom(const syncToServerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .daemon_name.serverInfo serInfo = 1;
  inline bool has_serinfo() const;
  inline void clear_serinfo();
  static const int kSerInfoFieldNumber = 1;
  inline const ::daemon_name::serverInfo& serinfo() const;
  inline ::daemon_name::serverInfo* mutable_serinfo();
  inline ::daemon_name::serverInfo* release_serinfo();
  inline void set_allocated_serinfo(::daemon_name::serverInfo* serinfo);

  // @@protoc_insertion_point(class_scope:daemon_name.syncToServerReq)
 private:
  inline void set_has_serinfo();
  inline void clear_has_serinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::daemon_name::serverInfo* serinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static syncToServerReq* default_instance_;
};
// -------------------------------------------------------------------

class syncToServerRsp : public ::google::protobuf::Message {
 public:
  syncToServerRsp();
  virtual ~syncToServerRsp();

  syncToServerRsp(const syncToServerRsp& from);

  inline syncToServerRsp& operator=(const syncToServerRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const syncToServerRsp& default_instance();

  void Swap(syncToServerRsp* other);

  // implements Message ----------------------------------------------

  syncToServerRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const syncToServerRsp& from);
  void MergeFrom(const syncToServerRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .daemon_name.daemon_msg_ret ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::daemon_name::daemon_msg_ret ret() const;
  inline void set_ret(::daemon_name::daemon_msg_ret value);

  // @@protoc_insertion_point(class_scope:daemon_name.syncToServerRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static syncToServerRsp* default_instance_;
};
// -------------------------------------------------------------------

class electionMasterReq : public ::google::protobuf::Message {
 public:
  electionMasterReq();
  virtual ~electionMasterReq();

  electionMasterReq(const electionMasterReq& from);

  inline electionMasterReq& operator=(const electionMasterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const electionMasterReq& default_instance();

  void Swap(electionMasterReq* other);

  // implements Message ----------------------------------------------

  electionMasterReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const electionMasterReq& from);
  void MergeFrom(const electionMasterReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .daemon_name.serverInfo serInfo = 1;
  inline bool has_serinfo() const;
  inline void clear_serinfo();
  static const int kSerInfoFieldNumber = 1;
  inline const ::daemon_name::serverInfo& serinfo() const;
  inline ::daemon_name::serverInfo* mutable_serinfo();
  inline ::daemon_name::serverInfo* release_serinfo();
  inline void set_allocated_serinfo(::daemon_name::serverInfo* serinfo);

  // @@protoc_insertion_point(class_scope:daemon_name.electionMasterReq)
 private:
  inline void set_has_serinfo();
  inline void clear_has_serinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::daemon_name::serverInfo* serinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static electionMasterReq* default_instance_;
};
// -------------------------------------------------------------------

class electionMasterRsp : public ::google::protobuf::Message {
 public:
  electionMasterRsp();
  virtual ~electionMasterRsp();

  electionMasterRsp(const electionMasterRsp& from);

  inline electionMasterRsp& operator=(const electionMasterRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const electionMasterRsp& default_instance();

  void Swap(electionMasterRsp* other);

  // implements Message ----------------------------------------------

  electionMasterRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const electionMasterRsp& from);
  void MergeFrom(const electionMasterRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .daemon_name.daemon_msg_ret ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::daemon_name::daemon_msg_ret ret() const;
  inline void set_ret(::daemon_name::daemon_msg_ret value);

  // @@protoc_insertion_point(class_scope:daemon_name.electionMasterRsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_daemon_2eproto();
  friend void protobuf_AssignDesc_daemon_2eproto();
  friend void protobuf_ShutdownFile_daemon_2eproto();

  void InitAsDefaultInstance();
  static electionMasterRsp* default_instance_;
};
// ===================================================================

class DaemonService_Stub;

class DaemonService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline DaemonService() {};
 public:
  virtual ~DaemonService();

  typedef DaemonService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void Register(::google::protobuf::RpcController* controller,
                       const ::daemon_name::registerReq* request,
                       ::daemon_name::registerRsp* response,
                       ::google::protobuf::Closure* done);
  virtual void LoginOut(::google::protobuf::RpcController* controller,
                       const ::daemon_name::loginOutReq* request,
                       ::daemon_name::loginOutRsp* response,
                       ::google::protobuf::Closure* done);
  virtual void heart(::google::protobuf::RpcController* controller,
                       const ::daemon_name::heartReq* request,
                       ::daemon_name::loginOutRsp* response,
                       ::google::protobuf::Closure* done);
  virtual void queryServer(::google::protobuf::RpcController* controller,
                       const ::daemon_name::queryServerReq* request,
                       ::daemon_name::queryServerRsp* response,
                       ::google::protobuf::Closure* done);
  virtual void queryDaemonMaster(::google::protobuf::RpcController* controller,
                       const ::daemon_name::queryDaemonMasterReq* request,
                       ::daemon_name::queryDaemonMasterRsp* response,
                       ::google::protobuf::Closure* done);
  virtual void syncServer(::google::protobuf::RpcController* controller,
                       const ::daemon_name::syncToServerReq* request,
                       ::daemon_name::syncToServerRsp* response,
                       ::google::protobuf::Closure* done);
  virtual void election(::google::protobuf::RpcController* controller,
                       const ::daemon_name::electionMasterReq* request,
                       ::daemon_name::electionMasterReq* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DaemonService);
};

class DaemonService_Stub : public DaemonService {
 public:
  DaemonService_Stub(::google::protobuf::RpcChannel* channel);
  DaemonService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~DaemonService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements DaemonService ------------------------------------------

  void Register(::google::protobuf::RpcController* controller,
                       const ::daemon_name::registerReq* request,
                       ::daemon_name::registerRsp* response,
                       ::google::protobuf::Closure* done);
  void LoginOut(::google::protobuf::RpcController* controller,
                       const ::daemon_name::loginOutReq* request,
                       ::daemon_name::loginOutRsp* response,
                       ::google::protobuf::Closure* done);
  void heart(::google::protobuf::RpcController* controller,
                       const ::daemon_name::heartReq* request,
                       ::daemon_name::loginOutRsp* response,
                       ::google::protobuf::Closure* done);
  void queryServer(::google::protobuf::RpcController* controller,
                       const ::daemon_name::queryServerReq* request,
                       ::daemon_name::queryServerRsp* response,
                       ::google::protobuf::Closure* done);
  void queryDaemonMaster(::google::protobuf::RpcController* controller,
                       const ::daemon_name::queryDaemonMasterReq* request,
                       ::daemon_name::queryDaemonMasterRsp* response,
                       ::google::protobuf::Closure* done);
  void syncServer(::google::protobuf::RpcController* controller,
                       const ::daemon_name::syncToServerReq* request,
                       ::daemon_name::syncToServerRsp* response,
                       ::google::protobuf::Closure* done);
  void election(::google::protobuf::RpcController* controller,
                       const ::daemon_name::electionMasterReq* request,
                       ::daemon_name::electionMasterReq* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DaemonService_Stub);
};


// ===================================================================


// ===================================================================

// serverInfo

// required int32 ip = 1;
inline bool serverInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void serverInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void serverInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void serverInfo::clear_ip() {
  ip_ = 0;
  clear_has_ip();
}
inline ::google::protobuf::int32 serverInfo::ip() const {
  return ip_;
}
inline void serverInfo::set_ip(::google::protobuf::int32 value) {
  set_has_ip();
  ip_ = value;
}

// required int32 port = 2;
inline bool serverInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void serverInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void serverInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void serverInfo::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 serverInfo::port() const {
  return port_;
}
inline void serverInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required string servername = 3;
inline bool serverInfo::has_servername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void serverInfo::set_has_servername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void serverInfo::clear_has_servername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void serverInfo::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& serverInfo::servername() const {
  return *servername_;
}
inline void serverInfo::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void serverInfo::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void serverInfo::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* serverInfo::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* serverInfo::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void serverInfo::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 serverid = 4;
inline bool serverInfo::has_serverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void serverInfo::set_has_serverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void serverInfo::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void serverInfo::clear_serverid() {
  serverid_ = GOOGLE_LONGLONG(0);
  clear_has_serverid();
}
inline ::google::protobuf::int64 serverInfo::serverid() const {
  return serverid_;
}
inline void serverInfo::set_serverid(::google::protobuf::int64 value) {
  set_has_serverid();
  serverid_ = value;
}

// optional string extend = 5;
inline bool serverInfo::has_extend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void serverInfo::set_has_extend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void serverInfo::clear_has_extend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void serverInfo::clear_extend() {
  if (extend_ != &::google::protobuf::internal::kEmptyString) {
    extend_->clear();
  }
  clear_has_extend();
}
inline const ::std::string& serverInfo::extend() const {
  return *extend_;
}
inline void serverInfo::set_extend(const ::std::string& value) {
  set_has_extend();
  if (extend_ == &::google::protobuf::internal::kEmptyString) {
    extend_ = new ::std::string;
  }
  extend_->assign(value);
}
inline void serverInfo::set_extend(const char* value) {
  set_has_extend();
  if (extend_ == &::google::protobuf::internal::kEmptyString) {
    extend_ = new ::std::string;
  }
  extend_->assign(value);
}
inline void serverInfo::set_extend(const char* value, size_t size) {
  set_has_extend();
  if (extend_ == &::google::protobuf::internal::kEmptyString) {
    extend_ = new ::std::string;
  }
  extend_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* serverInfo::mutable_extend() {
  set_has_extend();
  if (extend_ == &::google::protobuf::internal::kEmptyString) {
    extend_ = new ::std::string;
  }
  return extend_;
}
inline ::std::string* serverInfo::release_extend() {
  clear_has_extend();
  if (extend_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extend_;
    extend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void serverInfo::set_allocated_extend(::std::string* extend) {
  if (extend_ != &::google::protobuf::internal::kEmptyString) {
    delete extend_;
  }
  if (extend) {
    set_has_extend();
    extend_ = extend;
  } else {
    clear_has_extend();
    extend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// registerReq

// required int32 ip = 1;
inline bool registerReq::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void registerReq::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void registerReq::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void registerReq::clear_ip() {
  ip_ = 0;
  clear_has_ip();
}
inline ::google::protobuf::int32 registerReq::ip() const {
  return ip_;
}
inline void registerReq::set_ip(::google::protobuf::int32 value) {
  set_has_ip();
  ip_ = value;
}

// required int32 port = 2;
inline bool registerReq::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void registerReq::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void registerReq::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void registerReq::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 registerReq::port() const {
  return port_;
}
inline void registerReq::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required string servername = 3;
inline bool registerReq::has_servername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void registerReq::set_has_servername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void registerReq::clear_has_servername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void registerReq::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& registerReq::servername() const {
  return *servername_;
}
inline void registerReq::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void registerReq::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void registerReq::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* registerReq::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* registerReq::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void registerReq::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extend = 4;
inline bool registerReq::has_extend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void registerReq::set_has_extend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void registerReq::clear_has_extend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void registerReq::clear_extend() {
  if (extend_ != &::google::protobuf::internal::kEmptyString) {
    extend_->clear();
  }
  clear_has_extend();
}
inline const ::std::string& registerReq::extend() const {
  return *extend_;
}
inline void registerReq::set_extend(const ::std::string& value) {
  set_has_extend();
  if (extend_ == &::google::protobuf::internal::kEmptyString) {
    extend_ = new ::std::string;
  }
  extend_->assign(value);
}
inline void registerReq::set_extend(const char* value) {
  set_has_extend();
  if (extend_ == &::google::protobuf::internal::kEmptyString) {
    extend_ = new ::std::string;
  }
  extend_->assign(value);
}
inline void registerReq::set_extend(const char* value, size_t size) {
  set_has_extend();
  if (extend_ == &::google::protobuf::internal::kEmptyString) {
    extend_ = new ::std::string;
  }
  extend_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* registerReq::mutable_extend() {
  set_has_extend();
  if (extend_ == &::google::protobuf::internal::kEmptyString) {
    extend_ = new ::std::string;
  }
  return extend_;
}
inline ::std::string* registerReq::release_extend() {
  clear_has_extend();
  if (extend_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extend_;
    extend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void registerReq::set_allocated_extend(::std::string* extend) {
  if (extend_ != &::google::protobuf::internal::kEmptyString) {
    delete extend_;
  }
  if (extend) {
    set_has_extend();
    extend_ = extend;
  } else {
    clear_has_extend();
    extend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// registerRsp

// required .daemon_name.daemon_msg_ret ret = 1;
inline bool registerRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void registerRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void registerRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void registerRsp::clear_ret() {
  ret_ = 1;
  clear_has_ret();
}
inline ::daemon_name::daemon_msg_ret registerRsp::ret() const {
  return static_cast< ::daemon_name::daemon_msg_ret >(ret_);
}
inline void registerRsp::set_ret(::daemon_name::daemon_msg_ret value) {
  assert(::daemon_name::daemon_msg_ret_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// required int64 serverid = 2;
inline bool registerRsp::has_serverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void registerRsp::set_has_serverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void registerRsp::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void registerRsp::clear_serverid() {
  serverid_ = GOOGLE_LONGLONG(0);
  clear_has_serverid();
}
inline ::google::protobuf::int64 registerRsp::serverid() const {
  return serverid_;
}
inline void registerRsp::set_serverid(::google::protobuf::int64 value) {
  set_has_serverid();
  serverid_ = value;
}

// required string servername = 3;
inline bool registerRsp::has_servername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void registerRsp::set_has_servername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void registerRsp::clear_has_servername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void registerRsp::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& registerRsp::servername() const {
  return *servername_;
}
inline void registerRsp::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void registerRsp::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void registerRsp::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* registerRsp::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* registerRsp::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void registerRsp::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// loginOutReq

// required int64 serverid = 1;
inline bool loginOutReq::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void loginOutReq::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void loginOutReq::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void loginOutReq::clear_serverid() {
  serverid_ = GOOGLE_LONGLONG(0);
  clear_has_serverid();
}
inline ::google::protobuf::int64 loginOutReq::serverid() const {
  return serverid_;
}
inline void loginOutReq::set_serverid(::google::protobuf::int64 value) {
  set_has_serverid();
  serverid_ = value;
}

// required string servername = 2;
inline bool loginOutReq::has_servername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void loginOutReq::set_has_servername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void loginOutReq::clear_has_servername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void loginOutReq::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& loginOutReq::servername() const {
  return *servername_;
}
inline void loginOutReq::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void loginOutReq::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void loginOutReq::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* loginOutReq::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* loginOutReq::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void loginOutReq::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// loginOutRsp

// required .daemon_name.daemon_msg_ret ret = 1;
inline bool loginOutRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void loginOutRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void loginOutRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void loginOutRsp::clear_ret() {
  ret_ = 1;
  clear_has_ret();
}
inline ::daemon_name::daemon_msg_ret loginOutRsp::ret() const {
  return static_cast< ::daemon_name::daemon_msg_ret >(ret_);
}
inline void loginOutRsp::set_ret(::daemon_name::daemon_msg_ret value) {
  assert(::daemon_name::daemon_msg_ret_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// heartReq

// required int64 serverid = 1;
inline bool heartReq::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void heartReq::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void heartReq::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void heartReq::clear_serverid() {
  serverid_ = GOOGLE_LONGLONG(0);
  clear_has_serverid();
}
inline ::google::protobuf::int64 heartReq::serverid() const {
  return serverid_;
}
inline void heartReq::set_serverid(::google::protobuf::int64 value) {
  set_has_serverid();
  serverid_ = value;
}

// required string servername = 2;
inline bool heartReq::has_servername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void heartReq::set_has_servername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void heartReq::clear_has_servername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void heartReq::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& heartReq::servername() const {
  return *servername_;
}
inline void heartReq::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void heartReq::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void heartReq::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* heartReq::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* heartReq::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void heartReq::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// heartRsp

// required .daemon_name.daemon_msg_ret ret = 1;
inline bool heartRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void heartRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void heartRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void heartRsp::clear_ret() {
  ret_ = 1;
  clear_has_ret();
}
inline ::daemon_name::daemon_msg_ret heartRsp::ret() const {
  return static_cast< ::daemon_name::daemon_msg_ret >(ret_);
}
inline void heartRsp::set_ret(::daemon_name::daemon_msg_ret value) {
  assert(::daemon_name::daemon_msg_ret_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// queryServerReq

// required string servername = 1;
inline bool queryServerReq::has_servername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void queryServerReq::set_has_servername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void queryServerReq::clear_has_servername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void queryServerReq::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& queryServerReq::servername() const {
  return *servername_;
}
inline void queryServerReq::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void queryServerReq::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void queryServerReq::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* queryServerReq::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* queryServerReq::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void queryServerReq::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// queryServerRsp

// repeated .daemon_name.serverInfo serInfos = 1;
inline int queryServerRsp::serinfos_size() const {
  return serinfos_.size();
}
inline void queryServerRsp::clear_serinfos() {
  serinfos_.Clear();
}
inline const ::daemon_name::serverInfo& queryServerRsp::serinfos(int index) const {
  return serinfos_.Get(index);
}
inline ::daemon_name::serverInfo* queryServerRsp::mutable_serinfos(int index) {
  return serinfos_.Mutable(index);
}
inline ::daemon_name::serverInfo* queryServerRsp::add_serinfos() {
  return serinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::daemon_name::serverInfo >&
queryServerRsp::serinfos() const {
  return serinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::daemon_name::serverInfo >*
queryServerRsp::mutable_serinfos() {
  return &serinfos_;
}

// -------------------------------------------------------------------

// queryDaemonMasterReq

// -------------------------------------------------------------------

// queryDaemonMasterRsp

// required .daemon_name.serverInfo serInfo = 1;
inline bool queryDaemonMasterRsp::has_serinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void queryDaemonMasterRsp::set_has_serinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void queryDaemonMasterRsp::clear_has_serinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void queryDaemonMasterRsp::clear_serinfo() {
  if (serinfo_ != NULL) serinfo_->::daemon_name::serverInfo::Clear();
  clear_has_serinfo();
}
inline const ::daemon_name::serverInfo& queryDaemonMasterRsp::serinfo() const {
  return serinfo_ != NULL ? *serinfo_ : *default_instance_->serinfo_;
}
inline ::daemon_name::serverInfo* queryDaemonMasterRsp::mutable_serinfo() {
  set_has_serinfo();
  if (serinfo_ == NULL) serinfo_ = new ::daemon_name::serverInfo;
  return serinfo_;
}
inline ::daemon_name::serverInfo* queryDaemonMasterRsp::release_serinfo() {
  clear_has_serinfo();
  ::daemon_name::serverInfo* temp = serinfo_;
  serinfo_ = NULL;
  return temp;
}
inline void queryDaemonMasterRsp::set_allocated_serinfo(::daemon_name::serverInfo* serinfo) {
  delete serinfo_;
  serinfo_ = serinfo;
  if (serinfo) {
    set_has_serinfo();
  } else {
    clear_has_serinfo();
  }
}

// -------------------------------------------------------------------

// syncToServerReq

// required .daemon_name.serverInfo serInfo = 1;
inline bool syncToServerReq::has_serinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void syncToServerReq::set_has_serinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void syncToServerReq::clear_has_serinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void syncToServerReq::clear_serinfo() {
  if (serinfo_ != NULL) serinfo_->::daemon_name::serverInfo::Clear();
  clear_has_serinfo();
}
inline const ::daemon_name::serverInfo& syncToServerReq::serinfo() const {
  return serinfo_ != NULL ? *serinfo_ : *default_instance_->serinfo_;
}
inline ::daemon_name::serverInfo* syncToServerReq::mutable_serinfo() {
  set_has_serinfo();
  if (serinfo_ == NULL) serinfo_ = new ::daemon_name::serverInfo;
  return serinfo_;
}
inline ::daemon_name::serverInfo* syncToServerReq::release_serinfo() {
  clear_has_serinfo();
  ::daemon_name::serverInfo* temp = serinfo_;
  serinfo_ = NULL;
  return temp;
}
inline void syncToServerReq::set_allocated_serinfo(::daemon_name::serverInfo* serinfo) {
  delete serinfo_;
  serinfo_ = serinfo;
  if (serinfo) {
    set_has_serinfo();
  } else {
    clear_has_serinfo();
  }
}

// -------------------------------------------------------------------

// syncToServerRsp

// required .daemon_name.daemon_msg_ret ret = 1;
inline bool syncToServerRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void syncToServerRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void syncToServerRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void syncToServerRsp::clear_ret() {
  ret_ = 1;
  clear_has_ret();
}
inline ::daemon_name::daemon_msg_ret syncToServerRsp::ret() const {
  return static_cast< ::daemon_name::daemon_msg_ret >(ret_);
}
inline void syncToServerRsp::set_ret(::daemon_name::daemon_msg_ret value) {
  assert(::daemon_name::daemon_msg_ret_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// electionMasterReq

// required .daemon_name.serverInfo serInfo = 1;
inline bool electionMasterReq::has_serinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void electionMasterReq::set_has_serinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void electionMasterReq::clear_has_serinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void electionMasterReq::clear_serinfo() {
  if (serinfo_ != NULL) serinfo_->::daemon_name::serverInfo::Clear();
  clear_has_serinfo();
}
inline const ::daemon_name::serverInfo& electionMasterReq::serinfo() const {
  return serinfo_ != NULL ? *serinfo_ : *default_instance_->serinfo_;
}
inline ::daemon_name::serverInfo* electionMasterReq::mutable_serinfo() {
  set_has_serinfo();
  if (serinfo_ == NULL) serinfo_ = new ::daemon_name::serverInfo;
  return serinfo_;
}
inline ::daemon_name::serverInfo* electionMasterReq::release_serinfo() {
  clear_has_serinfo();
  ::daemon_name::serverInfo* temp = serinfo_;
  serinfo_ = NULL;
  return temp;
}
inline void electionMasterReq::set_allocated_serinfo(::daemon_name::serverInfo* serinfo) {
  delete serinfo_;
  serinfo_ = serinfo;
  if (serinfo) {
    set_has_serinfo();
  } else {
    clear_has_serinfo();
  }
}

// -------------------------------------------------------------------

// electionMasterRsp

// required .daemon_name.daemon_msg_ret ret = 1;
inline bool electionMasterRsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void electionMasterRsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void electionMasterRsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void electionMasterRsp::clear_ret() {
  ret_ = 1;
  clear_has_ret();
}
inline ::daemon_name::daemon_msg_ret electionMasterRsp::ret() const {
  return static_cast< ::daemon_name::daemon_msg_ret >(ret_);
}
inline void electionMasterRsp::set_ret(::daemon_name::daemon_msg_ret value) {
  assert(::daemon_name::daemon_msg_ret_IsValid(value));
  set_has_ret();
  ret_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace daemon_name

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::daemon_name::daemon_msg_ret>() {
  return ::daemon_name::daemon_msg_ret_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_daemon_2eproto__INCLUDED
